/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number }
type MaybeErrorWithCode = ErrorWithCode | null | undefined

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map()
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map()

/**
 * InvalidMetadata: 'Invalid Metadata Address'
 *
 * @category Errors
 * @category generated
 */
export class InvalidMetadataError extends Error {
  readonly code: number = 0x1770
  readonly name: string = 'InvalidMetadata'
  constructor() {
    super('Invalid Metadata Address')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidMetadataError)
    }
  }
}

createErrorFromCodeLookup.set(0x1770, () => new InvalidMetadataError())
createErrorFromNameLookup.set(
  'InvalidMetadata',
  () => new InvalidMetadataError()
)

/**
 * IncorrectFeeReduction: 'Fee reduction must be within 0-100'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectFeeReductionError extends Error {
  readonly code: number = 0x1771
  readonly name: string = 'IncorrectFeeReduction'
  constructor() {
    super('Fee reduction must be within 0-100')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectFeeReductionError)
    }
  }
}

createErrorFromCodeLookup.set(0x1771, () => new IncorrectFeeReductionError())
createErrorFromNameLookup.set(
  'IncorrectFeeReduction',
  () => new IncorrectFeeReductionError()
)

/**
 * MetadataCreatorParseError: 'Can't Parse The NFT's Creators'
 *
 * @category Errors
 * @category generated
 */
export class MetadataCreatorParseErrorError extends Error {
  readonly code: number = 0x1772
  readonly name: string = 'MetadataCreatorParseError'
  constructor() {
    super("Can't Parse The NFT's Creators")
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MetadataCreatorParseErrorError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1772,
  () => new MetadataCreatorParseErrorError()
)
createErrorFromNameLookup.set(
  'MetadataCreatorParseError',
  () => new MetadataCreatorParseErrorError()
)

/**
 * NftDoesntMatchCollectionPda: 'Provided NFT is not a member of provided collection'
 *
 * @category Errors
 * @category generated
 */
export class NftDoesntMatchCollectionPdaError extends Error {
  readonly code: number = 0x1773
  readonly name: string = 'NftDoesntMatchCollectionPda'
  constructor() {
    super('Provided NFT is not a member of provided collection')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NftDoesntMatchCollectionPdaError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1773,
  () => new NftDoesntMatchCollectionPdaError()
)
createErrorFromNameLookup.set(
  'NftDoesntMatchCollectionPda',
  () => new NftDoesntMatchCollectionPdaError()
)

/**
 * UnexpectedCreator: 'Creator of the NFT is not the expected creator'
 *
 * @category Errors
 * @category generated
 */
export class UnexpectedCreatorError extends Error {
  readonly code: number = 0x1774
  readonly name: string = 'UnexpectedCreator'
  constructor() {
    super('Creator of the NFT is not the expected creator')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UnexpectedCreatorError)
    }
  }
}

createErrorFromCodeLookup.set(0x1774, () => new UnexpectedCreatorError())
createErrorFromNameLookup.set(
  'UnexpectedCreator',
  () => new UnexpectedCreatorError()
)

/**
 * UnverifiedCreator: 'Creator of the NFT is not the expected creator'
 *
 * @category Errors
 * @category generated
 */
export class UnverifiedCreatorError extends Error {
  readonly code: number = 0x1775
  readonly name: string = 'UnverifiedCreator'
  constructor() {
    super('Creator of the NFT is not the expected creator')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UnverifiedCreatorError)
    }
  }
}

createErrorFromCodeLookup.set(0x1775, () => new UnverifiedCreatorError())
createErrorFromNameLookup.set(
  'UnverifiedCreator',
  () => new UnverifiedCreatorError()
)

/**
 * ConversionFailed: 'Couldnt up the number'
 *
 * @category Errors
 * @category generated
 */
export class ConversionFailedError extends Error {
  readonly code: number = 0x1776
  readonly name: string = 'ConversionFailed'
  constructor() {
    super('Couldnt up the number')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ConversionFailedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1776, () => new ConversionFailedError())
createErrorFromNameLookup.set(
  'ConversionFailed',
  () => new ConversionFailedError()
)

/**
 * NftTicketMismatch: 'Provided NFT is not stored in the NFT PDA'
 *
 * @category Errors
 * @category generated
 */
export class NftTicketMismatchError extends Error {
  readonly code: number = 0x1777
  readonly name: string = 'NftTicketMismatch'
  constructor() {
    super('Provided NFT is not stored in the NFT PDA')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NftTicketMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x1777, () => new NftTicketMismatchError())
createErrorFromNameLookup.set(
  'NftTicketMismatch',
  () => new NftTicketMismatchError()
)

/**
 * NotStakedLongEnough: 'NFT needs to be staked longer to withdraw'
 *
 * @category Errors
 * @category generated
 */
export class NotStakedLongEnoughError extends Error {
  readonly code: number = 0x1778
  readonly name: string = 'NotStakedLongEnough'
  constructor() {
    super('NFT needs to be staked longer to withdraw')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotStakedLongEnoughError)
    }
  }
}

createErrorFromCodeLookup.set(0x1778, () => new NotStakedLongEnoughError())
createErrorFromNameLookup.set(
  'NotStakedLongEnough',
  () => new NotStakedLongEnoughError()
)

/**
 * IncorrectCollectionAddresses: 'Ensure correct addresses for collection provided'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectCollectionAddressesError extends Error {
  readonly code: number = 0x1779
  readonly name: string = 'IncorrectCollectionAddresses'
  constructor() {
    super('Ensure correct addresses for collection provided')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectCollectionAddressesError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1779,
  () => new IncorrectCollectionAddressesError()
)
createErrorFromNameLookup.set(
  'IncorrectCollectionAddresses',
  () => new IncorrectCollectionAddressesError()
)

/**
 * ZeroValueRate: 'Ensure rate is non-zero'
 *
 * @category Errors
 * @category generated
 */
export class ZeroValueRateError extends Error {
  readonly code: number = 0x177a
  readonly name: string = 'ZeroValueRate'
  constructor() {
    super('Ensure rate is non-zero')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ZeroValueRateError)
    }
  }
}

createErrorFromCodeLookup.set(0x177a, () => new ZeroValueRateError())
createErrorFromNameLookup.set('ZeroValueRate', () => new ZeroValueRateError())

/**
 * ZeroValueEpoch: 'Ensure epoch is non-zero'
 *
 * @category Errors
 * @category generated
 */
export class ZeroValueEpochError extends Error {
  readonly code: number = 0x177b
  readonly name: string = 'ZeroValueEpoch'
  constructor() {
    super('Ensure epoch is non-zero')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ZeroValueEpochError)
    }
  }
}

createErrorFromCodeLookup.set(0x177b, () => new ZeroValueEpochError())
createErrorFromNameLookup.set('ZeroValueEpoch', () => new ZeroValueEpochError())

/**
 * CommunityMismatch: 'Community address does not match user community account'
 *
 * @category Errors
 * @category generated
 */
export class CommunityMismatchError extends Error {
  readonly code: number = 0x177c
  readonly name: string = 'CommunityMismatch'
  constructor() {
    super('Community address does not match user community account')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CommunityMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x177c, () => new CommunityMismatchError())
createErrorFromNameLookup.set(
  'CommunityMismatch',
  () => new CommunityMismatchError()
)

/**
 * TimeCapExceeded: 'Promotion period has ended'
 *
 * @category Errors
 * @category generated
 */
export class TimeCapExceededError extends Error {
  readonly code: number = 0x177d
  readonly name: string = 'TimeCapExceeded'
  constructor() {
    super('Promotion period has ended')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TimeCapExceededError)
    }
  }
}

createErrorFromCodeLookup.set(0x177d, () => new TimeCapExceededError())
createErrorFromNameLookup.set(
  'TimeCapExceeded',
  () => new TimeCapExceededError()
)

/**
 * TooFewCollectionsProvided: 'Length of total remaining accounts is equal to collection index vector'
 *
 * @category Errors
 * @category generated
 */
export class TooFewCollectionsProvidedError extends Error {
  readonly code: number = 0x177e
  readonly name: string = 'TooFewCollectionsProvided'
  constructor() {
    super(
      'Length of total remaining accounts is equal to collection index vector'
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TooFewCollectionsProvidedError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x177e,
  () => new TooFewCollectionsProvidedError()
)
createErrorFromNameLookup.set(
  'TooFewCollectionsProvided',
  () => new TooFewCollectionsProvidedError()
)

/**
 * EmptyVector: 'Length of collection and policy indexes vectors can't be zero'
 *
 * @category Errors
 * @category generated
 */
export class EmptyVectorError extends Error {
  readonly code: number = 0x177f
  readonly name: string = 'EmptyVector'
  constructor() {
    super("Length of collection and policy indexes vectors can't be zero")
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, EmptyVectorError)
    }
  }
}

createErrorFromCodeLookup.set(0x177f, () => new EmptyVectorError())
createErrorFromNameLookup.set('EmptyVector', () => new EmptyVectorError())

/**
 * TooManyCollections1: 'Number of collections larger than the number of indexes'
 *
 * @category Errors
 * @category generated
 */
export class TooManyCollections1Error extends Error {
  readonly code: number = 0x1780
  readonly name: string = 'TooManyCollections1'
  constructor() {
    super('Number of collections larger than the number of indexes')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TooManyCollections1Error)
    }
  }
}

createErrorFromCodeLookup.set(0x1780, () => new TooManyCollections1Error())
createErrorFromNameLookup.set(
  'TooManyCollections1',
  () => new TooManyCollections1Error()
)

/**
 * TooManyPolicies: 'Number of policies exceeds number of policy choices'
 *
 * @category Errors
 * @category generated
 */
export class TooManyPoliciesError extends Error {
  readonly code: number = 0x1781
  readonly name: string = 'TooManyPolicies'
  constructor() {
    super('Number of policies exceeds number of policy choices')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TooManyPoliciesError)
    }
  }
}

createErrorFromCodeLookup.set(0x1781, () => new TooManyPoliciesError())
createErrorFromNameLookup.set(
  'TooManyPolicies',
  () => new TooManyPoliciesError()
)

/**
 * TooManyCollections: 'Number of collections exceeds number of collection choices'
 *
 * @category Errors
 * @category generated
 */
export class TooManyCollectionsError extends Error {
  readonly code: number = 0x1782
  readonly name: string = 'TooManyCollections'
  constructor() {
    super('Number of collections exceeds number of collection choices')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TooManyCollectionsError)
    }
  }
}

createErrorFromCodeLookup.set(0x1782, () => new TooManyCollectionsError())
createErrorFromNameLookup.set(
  'TooManyCollections',
  () => new TooManyCollectionsError()
)

/**
 * CollectionPolicyMismatch: 'Provided collection policy does not match derived one'
 *
 * @category Errors
 * @category generated
 */
export class CollectionPolicyMismatchError extends Error {
  readonly code: number = 0x1783
  readonly name: string = 'CollectionPolicyMismatch'
  constructor() {
    super('Provided collection policy does not match derived one')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CollectionPolicyMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x1783, () => new CollectionPolicyMismatchError())
createErrorFromNameLookup.set(
  'CollectionPolicyMismatch',
  () => new CollectionPolicyMismatchError()
)

/**
 * CollectionMismatch: 'Provided collection does not match derived one'
 *
 * @category Errors
 * @category generated
 */
export class CollectionMismatchError extends Error {
  readonly code: number = 0x1784
  readonly name: string = 'CollectionMismatch'
  constructor() {
    super('Provided collection does not match derived one')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CollectionMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x1784, () => new CollectionMismatchError())
createErrorFromNameLookup.set(
  'CollectionMismatch',
  () => new CollectionMismatchError()
)

/**
 * IndexesMismatch: 'Index for collections and policies must be the same size'
 *
 * @category Errors
 * @category generated
 */
export class IndexesMismatchError extends Error {
  readonly code: number = 0x1785
  readonly name: string = 'IndexesMismatch'
  constructor() {
    super('Index for collections and policies must be the same size')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IndexesMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x1785, () => new IndexesMismatchError())
createErrorFromNameLookup.set(
  'IndexesMismatch',
  () => new IndexesMismatchError()
)

/**
 * IncorrectPolicyCount: 'Policy indexes must match the number of provided policies policy accounts'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectPolicyCountError extends Error {
  readonly code: number = 0x1786
  readonly name: string = 'IncorrectPolicyCount'
  constructor() {
    super(
      'Policy indexes must match the number of provided policies policy accounts'
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectPolicyCountError)
    }
  }
}

createErrorFromCodeLookup.set(0x1786, () => new IncorrectPolicyCountError())
createErrorFromNameLookup.set(
  'IncorrectPolicyCount',
  () => new IncorrectPolicyCountError()
)

/**
 * IncorrectCollectionCount: 'Collection indexes must match the number of provided collections accounts'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectCollectionCountError extends Error {
  readonly code: number = 0x1787
  readonly name: string = 'IncorrectCollectionCount'
  constructor() {
    super(
      'Collection indexes must match the number of provided collections accounts'
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectCollectionCountError)
    }
  }
}

createErrorFromCodeLookup.set(0x1787, () => new IncorrectCollectionCountError())
createErrorFromNameLookup.set(
  'IncorrectCollectionCount',
  () => new IncorrectCollectionCountError()
)

/**
 * CommunityLocked: 'Unable to withdraw from the community pool'
 *
 * @category Errors
 * @category generated
 */
export class CommunityLockedError extends Error {
  readonly code: number = 0x1788
  readonly name: string = 'CommunityLocked'
  constructor() {
    super('Unable to withdraw from the community pool')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CommunityLockedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1788, () => new CommunityLockedError())
createErrorFromNameLookup.set(
  'CommunityLocked',
  () => new CommunityLockedError()
)

/**
 * PolicyLocked: 'Unable to modify this policy'
 *
 * @category Errors
 * @category generated
 */
export class PolicyLockedError extends Error {
  readonly code: number = 0x1789
  readonly name: string = 'PolicyLocked'
  constructor() {
    super('Unable to modify this policy')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PolicyLockedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1789, () => new PolicyLockedError())
createErrorFromNameLookup.set('PolicyLocked', () => new PolicyLockedError())

/**
 * IncorrectSuperAdmin: 'Incorrect admin provided'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectSuperAdminError extends Error {
  readonly code: number = 0x178a
  readonly name: string = 'IncorrectSuperAdmin'
  constructor() {
    super('Incorrect admin provided')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectSuperAdminError)
    }
  }
}

createErrorFromCodeLookup.set(0x178a, () => new IncorrectSuperAdminError())
createErrorFromNameLookup.set(
  'IncorrectSuperAdmin',
  () => new IncorrectSuperAdminError()
)

/**
 * IncorrectSPLDecimals: 'Incorrect decimals. Exceeds 18'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectSPLDecimalsError extends Error {
  readonly code: number = 0x178b
  readonly name: string = 'IncorrectSPLDecimals'
  constructor() {
    super('Incorrect decimals. Exceeds 18')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectSPLDecimalsError)
    }
  }
}

createErrorFromCodeLookup.set(0x178b, () => new IncorrectSPLDecimalsError())
createErrorFromNameLookup.set(
  'IncorrectSPLDecimals',
  () => new IncorrectSPLDecimalsError()
)

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code)
  return createError != null ? createError() : null
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name)
  return createError != null ? createError() : null
}
